#include <SPI.h>        // Biblioteca para comunicação SPI (necessária para o RFID)
#include <MFRC522.h>    // Biblioteca para o módulo RFID MFRC522
#include <Wire.h>       // Biblioteca para comunicação I2C
#include <U8g2lib.h>    // Biblioteca para controle do display OLED
#include <Adafruit_NeoPixel.h> // Biblioteca para controle da fita de LED RGB (NeoPixel)

// ---------------------------- FACE 1 (RFID e Exibição de Informações display) ----------------------------

#define SS_PIN 53       	// Pino SS do RFID (para Arduino Mega)
#define RST_PIN 5       	// Pino de Reset do módulo RFID
#define TEMPO_EXIBICAO 2000  // Tempo padrão de exibição

#define BOTAO_F1_NOME   22  // Botão para exibir o nome da árvore
#define BOTAO_F1_ORIGEM 23  // Botão para exibir a origem da árvore
#define BOTAO_F1_COPA   28  // Botão para exibir o tipo de copa da árvore
#define BOTAO_F1_SAIDA  29  // Botão para sair da exibição


// Instanciação dos dispositivos
MFRC522 mfrc522(SS_PIN, RST_PIN);   // Objeto para controle do módulo RFID MFRC522
U8G2_SH1106_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE); // Objeto para controle do display OLED SH1106


// ---------------------------- FACE 2 (LEDs e Interação com PORTE) ----------------------------

#define PINO_FITA_F2 44
#define BOTAO_F2_INTERACAO 45
#define NUM_LEDS_F2 3

Adafruit_NeoPixel fitaF2(NUM_LEDS_F2, PINO_FITA_F2, NEO_GRB + NEO_KHZ800);

// ---------------------------- FACE 4 (LEDs e Interação com Meses/Floracao) ----------------------------

#define PINO_FITA_MONTH_F4 10 	/// Pino onde a fita de LEDs WS2812B (indicação dos meses) está conectada
#define NUM_LEDS_MONTH_F4 12  		// Número de LEDs para representar os meses de floração

#define PINO_FITA_FLOR 2 	// Pino onde a fita de LEDs WS2812B (indicação de presença de flor) está conectada
#define NUM_LEDS_FLOR 10   	//10 LEDs para indicar presença de flor

#define BOTAO_F4_INTERACAO 7  // Botão para interação com LEDs 

Adafruit_NeoPixel fita_FLOR(NUM_LEDS_FLOR, PINO_FITA_FLOR, NEO_GRB + NEO_KHZ800); // Objeto do LED indicador de flor
Adafruit_NeoPixel fita_MONTH_FLOR(NUM_LEDS_MONTH_F4, PINO_FITA_MONTH_F4, NEO_GRB + NEO_KHZ800); // Objeto dos LEDs indicadores dos meses


// ---------------------------- FACE 5 (LEDs e Interação com Meses/Frutos) ----------------------------

#define PINO_FITA_MONTH_F5 13 	// Pino onde a fita de LEDs WS2812B (indicação dos meses) está conectada
#define NUM_LEDS_MONTH_F5 12  	// Número de LEDs para representar os meses de frutificação

#define PINO_FITA_FRUIT_F5 12  	// Pino onde a fita de LEDs WS2812B (indicação de presença de frutos) está conectada
#define NUM_LEDS_FRUIT_F5 1   	// Apenas um LED para indicar presença de frutos

#define BOTAO_F5_INTERACAO 3  // Botão para interação com LEDs 

// Instanciação das fitas de LED NeoPixel
Adafruit_NeoPixel fita_FRUIT(NUM_LEDS_FRUIT_F5, PINO_FITA_FRUIT_F5, NEO_GRB + NEO_KHZ800); // Objeto do LED indicador de fruto
Adafruit_NeoPixel fita_MONTH_FRUIT(NUM_LEDS_MONTH_F5, PINO_FITA_MONTH_F5, NEO_GRB + NEO_KHZ800); // Objeto dos LEDs indicadores dos meses

/* 
 * Descrição das imagens de copas de árvores
 * ------------------------------------------
 * As variaveis abaixo sao arrays constantes armazenados em memória flash (PROGMEM),
 * representando imagens bitmap monocromáticas (formato XBM) de diferentes formatos
 * de copas de árvores para exibição em displays OLED 128x64.
 *
 * Tipos de copas representados:
 * - Copa Irregular: formato assimétrico e natural, representando copas menos uniformes.
 * - Copa Alongada: copa estreita e vertical, simulando árvores com crescimento predominantemente para cima.
 * - Copa Arredondada: copa com contornos suaves e arredondados, representando árvores de formato mais esférico.
 * - Copa Expansiva: copa ampla e espalhada, simulando árvores de cobertura mais horizontal.
 *
 * Origem: Todas as imagens foram geradas a partir de imagens base (PNG), convertidas para XBM.
 * Uso: As imagens são utilizadas para exibição gráfica da copa
 .
 */


const unsigned char alongada1[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xF0, 
  0xFF, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0xC0, 0xFF, 0xFF, 0x07, 
  0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0xF0, 
  0xFF, 0xFF, 0x0F, 0x00, 0xF0, 0xFF, 0xFF, 0x05, 0x00, 0xF8, 0xFF, 0xFF, 
  0x03, 0x00, 0xFC, 0xFF, 0xFF, 0x01, 0x00, 0xFC, 0x7F, 0xFF, 0x01, 0x00, 
  0xFC, 0xFD, 0xFF, 0x03, 0x00, 0xF8, 0xEB, 0xFF, 0x03, 0x00, 0xF8, 0xE7, 
  0xFF, 0x1F, 0x00, 0xFC, 0xF3, 0xFB, 0x1F, 0x00, 0xFC, 0xF2, 0xF7, 0x3F, 
  0x00, 0x7C, 0xC6, 0xF7, 0x7F, 0x00, 0x7C, 0xA6, 0xFF, 0x3F, 0x00, 0xFE, 
  0xF7, 0xFF, 0x7F, 0x00, 0xFE, 0xE1, 0xFF, 0x3F, 0x00, 0x5E, 0xE2, 0xFF, 
  0x7F, 0x00, 0x3E, 0xF0, 0xFF, 0x7F, 0x00, 0x0E, 0xF8, 0xFF, 0x7F, 0x00, 
  0x1E, 0xF8, 0xFF, 0x7F, 0x00, 0x08, 0xEF, 0xBF, 0x7C, 0x00, 0x80, 0xEF, 
  0xFF, 0x75, 0x00, 0x80, 0xFF, 0xEF, 0x31, 0x00, 0x80, 0xFF, 0x3F, 0x16, 
  0x00, 0x80, 0xFF, 0x1F, 0x3E, 0x00, 0x00, 0xFE, 0xFF, 0x3F, 0x00, 0x00, 
  0xBE, 0xFF, 0xFF, 0x01, 0x00, 0xBF, 0xFF, 0xFE, 0x01, 0x80, 0xBF, 0xFF, 
  0xEF, 0x01, 0x00, 0xFF, 0xFE, 0x7F, 0x00, 0x80, 0xFF, 0xFF, 0x3F, 0x00, 
  0x00, 0xFE, 0xFF, 0x3F, 0x00, 0x00, 0xC0, 0xFF, 0x07, 0x00, 0x00, 0xE0, 
  0xBF, 0x07, 0x00, 0x00, 0xC0, 0x7D, 0x07, 0x00, 0x00, 0x40, 0x7F, 0x03, 
  0x00, 0x00, 0xC0, 0xBD, 0x01, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0x00, 
  0xE0, 0x0F, 0x00, 0x00, 0x00, 0x40, 0x0C, 0x00, 0x00, 0x00, 0x40, 0x05, 
  0x00, 0x00, 0x00, 0x80, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 
  0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 
  0x0C, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0x00, 
  0x00, 0x00, 0xC0, 0x2D, 0x00, 0x00, };

const unsigned char alongada2[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 
  0x00, 0xF0, 0x02, 0x00, 0x00, 0xFC, 0x01, 0x00, 0x00, 0xFE, 0x03, 0x00, 
  0x00, 0xFE, 0x03, 0x00, 0xC0, 0xFF, 0x07, 0x00, 0xC0, 0xFF, 0x0F, 0x00, 
  0xC0, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0x1F, 0x00, 0x80, 0xFF, 0x7F, 0x00, 
  0x80, 0xFF, 0x3F, 0x00, 0xF0, 0xFF, 0x3F, 0x00, 0xE0, 0xFF, 0x7F, 0x00, 
  0xE0, 0xF3, 0x7F, 0x00, 0x80, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 
  0xF8, 0xFF, 0xFF, 0x00, 0xF8, 0xFF, 0xFF, 0x00, 0xF8, 0xFF, 0xFF, 0x00, 
  0xF0, 0xDF, 0xFF, 0x01, 0xF0, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0x00, 
  0xE0, 0xFF, 0xFF, 0x00, 0x80, 0xFF, 0x7F, 0x00, 0x80, 0xFF, 0x7F, 0x00, 
  0x80, 0x5F, 0xFB, 0x00, 0xC0, 0xFF, 0xFF, 0x01, 0xC0, 0xFF, 0xFF, 0x01, 
  0x80, 0xFF, 0xFF, 0x01, 0xE0, 0x7F, 0xFF, 0x00, 0xC0, 0xFF, 0x7F, 0x00, 
  0x80, 0x7D, 0x7C, 0x00, 0x80, 0x7F, 0x1E, 0x00, 0xC0, 0xCF, 0x0F, 0x00, 
  0x80, 0xF3, 0x0F, 0x00, 0x00, 0x63, 0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 
  0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
  0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
  0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
  0x10, 0x40, 0x10, 0x08, 0x10, 0x60, 0x12, 0x07, 0xBF, 0x6B, 0xBB, 0xCF, 
  };

const unsigned char expansiva1[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0xFF, 0xFB, 0x01, 0x00, 0x00, 0x00, 
  0xFC, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0xFF, 0xEF, 0xFF, 0x1F, 0x00, 
  0x00, 0xC0, 0xFF, 0xFF, 0xFD, 0x3F, 0x00, 0x00, 0xC0, 0xEC, 0xFE, 0xF7, 
  0x7F, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFC, 0x67, 0x03, 0x00, 0x00, 0xE0, 
  0xBF, 0xFF, 0xD1, 0x03, 0x00, 0x00, 0xD1, 0xFF, 0x7F, 0xC1, 0x0F, 0x00, 
  0x00, 0x7D, 0xF3, 0x4F, 0xC3, 0xFF, 0x00, 0x00, 0xE0, 0xFF, 0x03, 0x82, 
  0x3E, 0x00, 0x80, 0x83, 0xE7, 0x03, 0xB0, 0x3F, 0x00, 0xD0, 0x03, 0xFF, 
  0xFB, 0xFF, 0x43, 0x00, 0xFC, 0xDA, 0xFD, 0x7F, 0x3D, 0x00, 0x00, 0xA8, 
  0x7F, 0xF0, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 
  0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFC, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00,
};


const unsigned char expansiva2[] PROGMEM = {
   0x00, 0x00, 0x80, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0xF8, 
  0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0xFB, 0xFF, 0x7F, 0x0A, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x0F, 
  0x00, 0x00, 0x00, 0xFF, 0x7F, 0xFF, 0x0F, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 
  0xFF, 0x11, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0xFF, 0xFF, 0xDF, 0xFF, 0xFE, 0x01, 
  0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0xFF, 0xFF, 0xFB, 0xFF, 
  0xBF, 0x01, 0xF8, 0xFF, 0xFF, 0xF9, 0xEF, 0x3F, 0x00, 0xE8, 0xFF, 0x2F, 
  0xFB, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x7F, 0xFF, 0xF7, 0xFF, 0x00, 0xFB, 
  0xFF, 0xFF, 0xFF, 0xCB, 0xFF, 0x00, 0xFD, 0xF7, 0xBF, 0xD4, 0xAF, 0xFE, 
  0x01, 0xFE, 0xFF, 0x1F, 0xDC, 0xBF, 0x69, 0x03, 0xFC, 0xA7, 0x6F, 0xF8, 
  0x05, 0xF4, 0x1F, 0xFE, 0x27, 0x70, 0xA9, 0x0F, 0xFE, 0x13, 0x7E, 0xB7, 
  0x97, 0xAA, 0xFB, 0xFF, 0x3B, 0xFE, 0x23, 0x18, 0x4D, 0x4C, 0xF0, 0x0F, 
  0x5D, 0x20, 0x18, 0x4E, 0x49, 0xE0, 0x0C, 0x08, 0x08, 0x20, 0x98, 0x90, 
  0x40, 0x25, 0x00, 0x00, 0xC0, 0x78, 0x28, 0x80, 0x08, 0x00, 0x00, 0x00, 
  0x2B, 0x30, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
  0x00, 0x00, 0x00, };

const unsigned char expansivaAlternativa[] PROGMEM = {
   0x00, 0x00, 0xF8, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x90, 0xFF, 
  0xFF, 0x0F, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 
  0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x01, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xF8, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 
  0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF3, 0xF9, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x4F, 0x00, 0x00, 0x00, 0xFF, 0x7F, 
  0x80, 0x03, 0x00, 0x00, 0x00, 0xF1, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0x07, 0x00, 0x00, 0x00,
};

const unsigned char arredonda1[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
  0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xF9, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x7F, 0xF0, 0x1F, 0x00, 0x00, 0x00, 0xC0, 0xE9, 0xFF, 0xFF, 0x00, 
  0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x7F, 
  0xFC, 0x03, 0x00, 0x00, 0xFC, 0xF0, 0x1F, 0xF0, 0x03, 0x00, 0x00, 0xFF, 
  0xFE, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0xFF, 0x7F, 0xFE, 0xFF, 0x0F, 0x00, 
  0x00, 0xC3, 0x3F, 0xF8, 0xFF, 0x1F, 0x00, 0x80, 0xE3, 0x0F, 0xFA, 0xBF, 
  0x3F, 0x00, 0xE0, 0xFF, 0xD7, 0xFF, 0x1F, 0x3E, 0x00, 0xE0, 0xFF, 0xF7, 
  0xFB, 0xFF, 0x38, 0x00, 0xF0, 0xFE, 0xFD, 0xFF, 0xDF, 0x7F, 0x00, 0xF0, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF8, 0x3F, 0x7F, 0x82, 0xFF, 0xFF, 
  0x00, 0xF0, 0xDF, 0x1F, 0xF8, 0xF0, 0xFF, 0x00, 0x3C, 0xFC, 0x07, 0xFE, 
  0xE3, 0xFF, 0x03, 0x1C, 0xFE, 0xE7, 0xFE, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 
  0x7D, 0xF6, 0xDF, 0xDF, 0x03, 0xEC, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 
  0xFC, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFC, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x01, 0xFC, 0xFF, 0xBB, 0xDD, 0x7C, 0xFF, 0x01, 0xFC, 
  0xBF, 0xB7, 0x7F, 0xB6, 0xFF, 0x03, 0x20, 0x08, 0x6E, 0xBB, 0xFB, 0xFF, 
  0x03, 0xF8, 0x58, 0xDB, 0xDA, 0x7E, 0xFD, 0x01, 0xFC, 0xA1, 0xB4, 0x5F, 
  0xE1, 0xE0, 0x01, 0xFC, 0x27, 0xB5, 0xEF, 0x3C, 0x0E, 0x00, 0xFC, 0x5F, 
  0xCE, 0xEF, 0x8F, 0x1F, 0x00, 0xE0, 0x1F, 0xD9, 0x7F, 0x80, 0x7F, 0x00, 
  0xF0, 0x0F, 0xB6, 0x1F, 0x18, 0x7E, 0x00, 0xC0, 0xF1, 0xFC, 0x5F, 0x7E, 
  0x00, 0x00, 0x00, 0xF8, 0xF3, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0xF8, 0xC7, 
  0x1F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 
};

const unsigned char arredonda2[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF7, 0x00, 0x00, 0x00, 0x00, 
  0x80, 0xFB, 0xFB, 0x07, 0x00, 0x00, 0x00, 0xC0, 0x3F, 0xA7, 0x0D, 0x00, 
  0x00, 0x00, 0x30, 0x3E, 0x6F, 0x32, 0x00, 0x00, 0x00, 0xF8, 0x7B, 0xF0, 
  0x77, 0x00, 0x00, 0x00, 0xC0, 0x67, 0xEF, 0x8E, 0x00, 0x00, 0x00, 0xFE, 
  0x8F, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x3F, 0x70, 0xDF, 0xFF, 0x02, 0x00, 
  0x00, 0xDE, 0x37, 0xEE, 0xF7, 0x07, 0x00, 0x80, 0xEC, 0xEF, 0x9A, 0xF7, 
  0x05, 0x00, 0xC0, 0xEF, 0xF7, 0xBF, 0xD8, 0x04, 0x00, 0xE0, 0xEF, 0xFB, 
  0xFC, 0x07, 0x0F, 0x00, 0xE0, 0x33, 0xF7, 0x3C, 0x7B, 0x1F, 0x00, 0x20, 
  0x7C, 0x8C, 0x47, 0xFC, 0x18, 0x00, 0x90, 0x7F, 0x3B, 0xF3, 0xFB, 0x0F, 
  0x00, 0xE0, 0xBF, 0x57, 0xB2, 0xF3, 0x1F, 0x00, 0xF0, 0x7F, 0x72, 0x3F, 
  0xDD, 0x3F, 0x00, 0xF8, 0xA1, 0x6B, 0x6F, 0x57, 0x7F, 0x00, 0xF8, 0x7F, 
  0x57, 0xAD, 0xFB, 0x7D, 0x00, 0x70, 0xF7, 0xDC, 0xF7, 0x7C, 0x38, 0x00, 
  0x80, 0xB7, 0xE8, 0x73, 0xFA, 0x36, 0x00, 0x30, 0x79, 0xBF, 0x1B, 0xF9, 
  0x6F, 0x00, 0x98, 0x7B, 0xBE, 0x8F, 0xE3, 0x1F, 0x00, 0xE0, 0x23, 0xB2, 
  0xF7, 0x19, 0x3F, 0x00, 0xF0, 0xCF, 0xF5, 0x4F, 0xEE, 0x3D, 0x00, 0xF0, 
  0xFF, 0xEB, 0xEF, 0x7F, 0x38, 0x00, 0xC0, 0x20, 0xCE, 0xFF, 0x11, 0x1C, 
  0x00, 0xE0, 0xCE, 0xFF, 0x9F, 0xEF, 0x1B, 0x00, 0x80, 0x7F, 0xF8, 0x4F, 
  0xF8, 0x07, 0x00, 0x80, 0x9F, 0xE7, 0x7F, 0xE7, 0x0F, 0x00, 0x80, 0xDF, 
  0xCF, 0xDF, 0xCF, 0x07, 0x00, 0x00, 0xEF, 0xDF, 0xEF, 0x9F, 0x03, 0x00, 
  0x00, 0xF0, 0x9F, 0xEF, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x8F, 0xCF, 0x07, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, };


const unsigned char irregular1[] PROGMEM =  {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
  0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x88, 0x10, 0x00, 
  0x00, 0x00, 0x80, 0x3D, 0x05, 0x00, 0x80, 0x43, 0xBF, 0x00, 0x00, 0x80, 
  0x67, 0x97, 0x1C, 0x00, 0x80, 0xFD, 0xF5, 0x1E, 0x00, 0x00, 0xEC, 0x7F, 
  0x1F, 0x00, 0x00, 0xF4, 0xFF, 0x03, 0x00, 0x80, 0xF5, 0xFF, 0x05, 0x00, 
  0x98, 0xFF, 0xFF, 0x0F, 0x00, 0x5C, 0xFE, 0x7F, 0x1F, 0x00, 0xC0, 0xFE, 
  0xFF, 0x07, 0x04, 0xD8, 0xFE, 0xFF, 0x1F, 0x02, 0xE7, 0xFE, 0xFF, 0x4F, 
  0x16, 0x80, 0xFF, 0xFF, 0x5F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 
  0xFF, 0xFF, 0x7F, 0x06, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 
  0xFF, 0x00, 0x00, 0xFE, 0xAF, 0xFF, 0x03, 0x80, 0xF3, 0xFF, 0xBE, 0x01, 
  0x00, 0xF6, 0xFF, 0xFB, 0x01, 0x80, 0x3A, 0xFF, 0xFF, 0x01, 0x40, 0xBE, 
  0x4F, 0x2F, 0x00, 0x00, 0xFE, 0x9F, 0x06, 0x00, 0x00, 0xCF, 0xC5, 0x14, 
  0x00, 0x00, 0x00, 0x80, 0x19, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 
  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, };

const unsigned char irregular2[] PROGMEM =  {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0xA7, 0x65, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xEB, 
  0x01, 0x01, 0x00, 0x00, 0x00, 0xF8, 0xF3, 0x5D, 0x20, 0x00, 0x00, 0x00, 
  0x78, 0x5D, 0x0D, 0x10, 0x00, 0x00, 0x00, 0x78, 0xEC, 0xB6, 0x16, 0x00, 
  0x00, 0x00, 0x00, 0xAF, 0x3E, 0x64, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x6E, 
  0x2D, 0x00, 0x00, 0x00, 0xDD, 0xFD, 0xE7, 0x9E, 0x01, 0x00, 0x80, 0x36, 
  0xE8, 0x0A, 0xB7, 0x06, 0x00, 0x00, 0x08, 0xEA, 0x55, 0x7F, 0x07, 0x00, 
  0x40, 0x5A, 0x95, 0x5D, 0xDF, 0x23, 0x00, 0xD0, 0x21, 0xAE, 0xC7, 0xBE, 
  0x1D, 0x00, 0x80, 0x20, 0x84, 0x68, 0xF3, 0x0D, 0x00, 0x40, 0x33, 0xD0, 
  0xDF, 0xB7, 0x09, 0x00, 0x40, 0x34, 0x98, 0xFF, 0x8F, 0x00, 0x00, 0x80, 
  0xA5, 0xB8, 0xE7, 0x3B, 0x01, 0x00, 0xFC, 0xFD, 0x3F, 0x75, 0xFF, 0x00, 
  0x00, 0xF8, 0x7F, 0xDE, 0xFE, 0xED, 0x00, 0x00, 0x70, 0x4C, 0xFC, 0x53, 
  0x47, 0x01, 0x00, 0xB0, 0x89, 0xEC, 0xCE, 0x4B, 0x00, 0x00, 0xDE, 0xFC, 
  0xC9, 0x9F, 0xFD, 0x0B, 0x00, 0x78, 0x0D, 0x45, 0x9E, 0x2F, 0x23, 0x00, 
  0xA8, 0x01, 0x06, 0xED, 0xF9, 0x1E, 0x00, 0xB0, 0xC1, 0x06, 0xDE, 0xFD, 
  0x47, 0x00, 0x90, 0x11, 0x02, 0xEC, 0xDF, 0x80, 0x00, 0x84, 0x03, 0x04, 
  0x7C, 0x17, 0x2C, 0x00, 0xC0, 0x03, 0x08, 0xBD, 0xED, 0x8F, 0x00, 0x00, 
  0x01, 0x10, 0xBA, 0xFF, 0x64, 0x00, 0x00, 0x00, 0x60, 0xF3, 0x01, 0x10, 
  0x00, 0x00, 0x00, 0x80, 0xE7, 0x0D, 0x20, 0x00, 0x00, 0x00, 0x00, 0xC2, 
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, };

const unsigned char pinheiro[] PROGMEM =  {

   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x60, 0x07, 0x00, 0x00, 0x00, 0x40, 0x0E, 0x00, 
  0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00, 0x40, 0x19, 0x00, 0x00, 0x00, 
  0xD0, 0x1D, 0x00, 0x00, 0x00, 0x70, 0x3F, 0x00, 0x00, 0x00, 0xF0, 0x1B, 
  0x00, 0x00, 0x00, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x17, 0x1D, 0x00, 0x00, 
  0x00, 0xFC, 0x7F, 0x00, 0x00, 0x00, 0x78, 0x11, 0x00, 0x00, 0x00, 0xC8, 
  0x27, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0xFE, 0xFF, 0x01, 
  0x00, 0x00, 0xF4, 0xB7, 0x00, 0x00, 0x00, 0xFF, 0x9F, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0x01, 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0xF8, 0x57, 
  0x00, 0x00, 0x00, 0xF0, 0x1F, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x0F, 0x00, 
  0x00, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0xFC, 0xFF, 0x03, 0x00, 0x80, 0xFF, 
  0x1F, 0x00, 0x00, 0x00, 0xEB, 0xFF, 0x0B, 0x00, 0x00, 0xF8, 0xFF, 0x1F, 
  0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00, 0xE0, 0xFF, 0xFF, 0x03, 0x00, 0xC0, 
  0xFF, 0x7F, 0x00, 0x00, 0x00, 0xF2, 0xFF, 0x0F, 0x00, 0x00, 0xFE, 0xFF, 
  0x0F, 0x00, 0xF0, 0xFF, 0xFF, 0x3F, 0x00, 0xF0, 0xFF, 0xFF, 0x3F, 0x00, 
  0xE0, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0xF8, 
  0xFF, 0x7F, 0x00, 0xF0, 0xFF, 0xFF, 0x5F, 0x00, 0xE0, 0xFF, 0xFF, 0x3F, 
  0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 
  0xFF, 0xFF, 0xFF, 0x00, 0xFC, 0xFF, 0xFF, 0x01, 0x00, 0xFC, 0xFF, 0xFF, 
  0x07, 0x00, 0xB0, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0x01, 
  0xF8, 0xFF, 0xFF, 0x3F, 0x00, 0xC0, 0xFF, 0xFF, 0x45, 0x00, 0xFC, 0xFF, 
  0xFF, 0x07, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x03, 0xE8, 0xFF, 0xFF, 0xFF, 
  0x03, 0xEC, 0xFF, 0xFF, 0xFF, 0x01, 0xFC, 0xFF, 0xFF, 0xFF, 0x01, 0xFD, 
  0xFF, 0xFF, 0x7F, 0x00, 0xD0, 0x7F, 0xFF, 0xFF, 0x03, 0xE0, 0x1F, 0xFF, 
  0xFF, 0x00, 0xC0, 0x0E, 0xF7, 0x1D, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 
  };



struct Arvore {
  const char* nome;
  const char* copa;
  const char* pais_origem;
  const char* bioma;
  const int porte[4];
  const int presenca_fruto;
  const int meses_fruto[12];
  const int presenca_flor;
  const int meses_flor[12];
  const int cor_da_flor[3];
};

constexpr Arvore arvores[] = {
  {"Nome: Aroeira", "Copa: Irregular", "America do Sul", "Mata Atlantica", {1, 0, 0}, 1, {0,1,1,1,1,0,0,0,0,0,0,0}, 1, {1,1,1,1,1,1,0,0,0,0,0,0}, {255, 255, 255}}, // branco  
  {"Nome: Cutieira", "Copa: Alongada", "Brasil", "Mata Atlantica", {0, 0, 1}, 1, {0,0,0,0,0,0,1,1,1,0,0,0}, 1, {0,0,1,1,1,0,0,0,0,0,0,0}, {255, 255, 255}}, // branco  
  {"Nome: Pau-Ferro", "Copa: Expansiva/Guarda-chuva", "Brasil", "Caatinga", {0, 1, 0}, 1, {0,0,0,1,1,1,1,0,0,0,0,0}, 1, {0,0,0,0,1,1,1,0,0,0,0,0}, {255, 255, 0}}, // amarelo  
  {"Nome: Ipe-Rosa", "Copa: Expansiva/Guarda-chuva", "America do Sul", "Cerrado", {0, 1, 0}, 1, {0,0,0,0,0,0,1,1,1,0,0,0}, 1, {0,0,0,1,1,1,0,0,0,0,0,0}, {255, 20, 147}}, // rosa  
  {"Nome: Jaqueira", "Copa: Alongada", "India", "diversos", {0, 0, 1}, 1, {0,0,0,0,0,0,1,1,1,0,0,0}, 1, {0,0,1,1,1,1,0,0,0,0,0,0}, {0, 255, 0}}, // verde  
  {"Nome: Goiabeira", "Copa: Irregular", "Americas", "Mata Atlantica", {0, 1, 0}, 1, {0,1,1,1,0,0,0,0,0,0,0,0}, 1, {0,0,0,1,1,1,1,0,0,0,0,0}, {255, 255, 255}}, // branco  
  {"Nome: Jambeira", "Copa: Arredondada", "Malasia", "diverso", {0, 1, 0}, 1, {0,1,1,1,0,0,0,0,0,0,0,0}, 1, {0,0,1,1,1,1,1,0,0,0,0,0}, {255, 20, 147}}, // rosa  
  {"Nome: Pitangueira", "Copa: Irregular", "America do Sul", "Mata Atlantica", {1, 0, 0}, 1, {0,1,1,1,0,0,0,0,0,0,0,0}, 1, {0,0,1,1,1,0,0,0,1,1,0,0}, {255, 255, 255}}, // branco  
  {"Nome: Cajueiro", "Copa: Irregular", "Brasil", "Caatinga", {1, 0, 0}, 1, {1,1,1,1,1,0,0,0,0,0,0,0}, 1, {0,0,0,1,1,1,1,0,0,0,0,0}, {255, 0, 0}}, // vermelho    
  {"Nome: Amoreira", "Copa: Irregular", "Asia", "diversos", {1, 0, 0}, 1, {0,1,1,1,0,0,0,0,0,0,0,0}, 1, {0,0,1,1,1,0,0,0,0,0,0,0}, {144, 238, 144}}, // verde claro 
  {"Nome: Pinheiro","Copa: Conica","Europa", "diversos", {0, 0, 1}, 0, {0,0,0,0,0,0,0,0,0,0,0,0}, 0, {0,0,0,0,0,0,0,0,0,0,0,0}, {0, 0, 0}}
 
};

// Lista de UIDs associados às árvores, na mesma ordem do array arvores
constexpr byte uids[][4] = {
  {0xCF, 0x87, 0x78, 0x41},  // Aroeira
  {0xCE, 0xBE, 0x70, 0x41},  // Cutieira
  {0x37, 0xE0, 0x78, 0x41},  // Pau-Ferro
  {0xDB, 0x6D, 0x78, 0x41},  // Ipê-Rosa
  {0x8A, 0x9C, 0x78, 0x41},  // Jaqueira
  {0x00, 0xAA, 0x78, 0x41},  // Goiabeira
  {0xF6, 0xB7, 0x70, 0x41},  // Jambeira
  {0xCE, 0x71, 0x78, 0x41},  // Pitangueira
  {0xAC, 0xA8, 0x78, 0x41},  // Cajueiro
  {0xE3, 0xB6, 0x78, 0x41},  // Amoreira
  {0xD3, 0xC7, 0x4D, 0x04},  // Pinheiro
};


void exibirMensagemInicial() {
  display.clearBuffer();
  display.setFont(u8g2_font_ncenB08_tr);
  display.drawStr(20, 30, "Aproxime-se de");
  display.drawStr(20, 50, " uma arvore ... !");
  display.sendBuffer();
  delay(TEMPO_EXIBICAO);
}

void setup() {
  Serial.begin(9600);  // Inicializa a comunicação serial

   
  // Inicialização do leitor RFID
  SPI.begin();            // Inicia a comunicação SPI (necessária para o RFID)
  mfrc522.PCD_Init();     // Inicializa o módulo RFID
  Serial.println("Aproxime a tag RFID da árvore...");


  // ---------------------------------------------FACE 1-------------------------------------------------------------
  pinMode(BOTAO_F1_NOME, INPUT_PULLUP); // Ativa resistor pull-up interno para manter o pino em HIGH quando solto
  pinMode(BOTAO_F1_ORIGEM, INPUT_PULLUP); // Ativa resistor pull-up interno para evitar ruídos elétricos
  pinMode(BOTAO_F1_COPA, INPUT_PULLUP); // Configura o botão com resistor  interno do microcontrolador
  pinMode(BOTAO_F1_SAIDA, INPUT_PULLUP); // Mantém o pino em HIGH até que o botão seja pressionado
  
  // Inicialização do display OLED
  display.begin(); // Inicia a comunicação com o display
  exibirMensagemInicial(); // Exibe uma mensagem de boas-vindas

  // ---------------------------------------------FACE 2-------------------------------------------------------------

  pinMode(BOTAO_F2_INTERACAO, INPUT_PULLUP);
  fitaF2.begin();
  fitaF2.show();  // Inicializa a fita apagada

  // ---------------------------------------------FACE 4-------------------------------------------------------------

  pinMode(BOTAO_F4_INTERACAO, INPUT_PULLUP);  // Configura o pino do botão de interação como entrada
  fita_FLOR.begin();   // Inicializa a fita de LED para indicação de flor
  fita_FLOR.show();    // Garante que os LEDs comecem apagados
  fita_MONTH_FLOR.begin();   // Inicializa a fita de LED para indicação dos meses
  fita_MONTH_FLOR.show();    // Garante que os LEDs comecem apagados

    // ---------------------------------------------FACE 5-------------------------------------------------------------

  pinMode(BOTAO_F5_INTERACAO, INPUT_PULLUP);  // Configura o pino do botão de interação como entrada
  fita_FRUIT.begin();   // Inicializa a fita de LED para indicação de fruto
  fita_FRUIT.show();    // Garante que os LEDs comecem apagados
  fita_MONTH_FRUIT.begin();   // Inicializa a fita de LED para indicação dos meses
  fita_MONTH_FRUIT.show();    // Garante que os LEDs comecem apagados

}
// ---------------------------------------IDENTIFICACAO DA TAG RFID-----------------------------------

/**
 * @brief Lê o UID de uma tag RFID e armazena no buffer fornecido.
 * 
 * @param uidBuffer Ponteiro para um array de bytes onde o UID será armazenado.
 * @return true Se um novo cartão RFID foi detectado e lido com sucesso.
 * @return false Se nenhum cartão foi encontrado ou se a leitura falhou.
 * 
 * @details 
 * - Utiliza a biblioteca MFRC522 para verificar a presença de um novo cartão RFID.
 * - Se um cartão estiver presente e puder ser lido, seu UID será copiado para `uidBuffer`.
 * - Exibe o UID no monitor serial em formato hexadecimal.
 * - Se não houver cartão ou a leitura falhar, retorna `false`.
 * 
 * @note 
 * - `uidBuffer` deve ter pelo menos 4 bytes de espaço disponível.
 * - A função depende de `mfrc522` estar corretamente inicializado e configurado.
 */

bool lerUID(byte* uidBuffer) {
  if (!mfrc522.PICC_IsNewCardPresent() || !mfrc522.PICC_ReadCardSerial()) {
    
    return false;  // Nenhum novo cartão detectado ou falha na leitura  
  }

  Serial.print("UID lido: ");
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    Serial.print(mfrc522.uid.uidByte[i] < 0x10 ? " 0" : " ");
    Serial.print(mfrc522.uid.uidByte[i], HEX);
    uidBuffer[i] = mfrc522.uid.uidByte[i];  // Copia UID para buffer externo
  }
  return true;
}

/**
 * @brief Procura um UID na lista de UIDs armazenados e retorna seu índice.
 * 
 * @param uid Ponteiro para o array de 4 bytes representando o UID a ser buscado.
 * @return (int) O índice do UID encontrado no array `uids`, ou -1 se não for encontrado.
 * 
 * @details 
 * - Percorre o array `uids`, comparando cada entrada com o UID fornecido.
 * - Usa `memcmp()` para verificar se os 4 bytes do UID coincidem com algum armazenado.
 * - Retorna o índice correspondente caso haja correspondência.
 * - Retorna -1 se o UID não for encontrado.
 * 
 */
int procurarArvorePorUID(const byte* uid) {
  for (int i = 0; i < sizeof(uids) / sizeof(uids[0]); i++) {
    if (memcmp(uid, uids[i], 4) == 0) {
      return i;  // Retorna o índice correspondente
    }
  }
  return -1;  // Retorna -1 caso o UID não seja encontrado
}

  // ---------------------------------------------FACE 2 - PORTE -------------------------------------------------------------


/**
 * @brief Atualiza os LEDs da fita F2 para indicar o porte da árvore.
 * 
 * @param status Indica se o LED correspondente ao porte deve ser aceso (1) ou apagado (0).
 * @param arvore Ponteiro para a estrutura `Arvore`, que contém informações sobre o porte da árvore.
 * 
 * @details
 * - Se `status` for 1, percorre o array `porte` e acende apenas um LED correspondente:
 *   - **Verde** para porte pequeno (`porte[0] == 1`)
 *   - **Azul** para porte médio (`porte[1] == 1`)
 *   - **Vermelho** para porte grande (`porte[2] == 1`)
 * - Apenas um dos três LEDs será aceso, pois a estrutura `Arvore` indica um único porte.
 * - Se `status` for 0, todos os LEDs são apagados.
 * - O LED apagado é representado por `fitaF2.Color(0, 0, 0)`.
 */
void atualizarLeds_F2(int status, const Arvore* arvore) {
    
  fitaF2.clear();
  
  if (status) {
    for (int i = 0; i < NUM_LEDS_F2; i++) { // Apenas os três primeiros índices do porte são relevantes
      if (arvore->porte[i]) {
          uint32_t cor;

          if (i == 0) {
              cor = fitaF2.Color(0, 255, 200);  // **Azul Turquesa** (Porte pequeno)
          } else if (i == 1) {
              cor = fitaF2.Color(90, 0, 255);  // **Azul violeta** (Porte médio)
          } else {
              cor = fitaF2.Color(255, 0, 0);  // **Vermelho** (Porte grande)
          }

          fitaF2.setPixelColor(i, cor);
          fitaF2.show();
          break; // Garante que apenas um LED seja aceso
      }
    }
  } else {
      fitaF2.clear();
      fitaF2.show(); // Mantém os LEDs apagados até ativação
  }
}


// ---------------------------------------------FACE 4 - FLORACAO -------------------------------------------------------------

/**
 * @brief Atualiza a fita de LEDs para indicar os meses de floração da árvore.
 * 
 * @param arvore Ponteiro para a estrutura `Arvore`, que contém informações sobre os meses de floração.
 * 
 * @details
 * - Percorre os LEDs da fita `fita_MONTH_FLOR` e acende aqueles correspondentes aos meses de floração.
 * - Se `meses_flor[i]` for 1, o LED correspondente acende em **rosa** (`RGB(255, 20, 147)`).
 * - Se `meses_flor[i]` for 0, o LED correspondente é apagado.
 */
void fita_MONTH_mudanca_cor_F4(const Arvore *arvore) {
    for (int i = 0; i < NUM_LEDS_MONTH_F4; i++) {
        if (arvore->meses_flor[i]) {
            delay(1000);
            fita_MONTH_FLOR.setPixelColor(i, fita_FLOR.Color(0, 0, 255));  //azul
            fita_MONTH_FLOR.show();
        } else {
            fita_MONTH_FLOR.setPixelColor(i, fita_FLOR.Color(0, 0, 0)); // Apagar LED
        }
    }
}

/**
 * @brief Atualiza os LEDs para indicar a cor da flor da árvore e os meses de floração.
 * 
 * @param status Indica se os LEDs devem ser acesos (1) ou apagados (0).
 * @param arvore Ponteiro para a estrutura `Arvore`, que contém informações sobre a cor da flor e os meses de floração.
 * 
 * @details
 * - Se `status` for 1:
 *   - A fita `fita_FLOR` acende com a cor da flor definida em `cor_da_flor[]`.
 *   - A função `fita_MONTH_mudanca_cor_F4()` é chamada para acender os LEDs dos meses de floração.
 * - Se `status` for 0, todas as fitas são apagadas.
 */
void atualizarLeds_F4(int status, const Arvore* arvore) {
    
    if (status) {
        fita_FLOR.clear();
        fita_MONTH_FLOR.clear();

        for (int i = 0; i < NUM_LEDS_FLOR; i++) {
            fita_FLOR.setPixelColor(i, fita_FLOR.Color(arvore->cor_da_flor[0], arvore->cor_da_flor[1], arvore->cor_da_flor[2]));
            fita_FLOR.show();
      
        }

        fita_MONTH_mudanca_cor_F4(arvore);
    
    } else {
        fita_FLOR.clear();
        fita_FLOR.show(); // Mantém os LEDs apagados
        fita_MONTH_FLOR.clear();
        fita_MONTH_FLOR.show();
    }
}

// ---------------------------------------------FACE 5 - FRUTO -------------------------------------------------------------

/**
 * @brief Atualiza a fita de LEDs para indicar os meses de frutificação da árvore.
 * 
 * @param arvore Ponteiro para a estrutura `Arvore`, que contém informações sobre os meses de frutificação.
 * 
 * @details
 * - Percorre os LEDs da fita `fita_MONTH_FRUIT` e acende aqueles correspondentes aos meses de frutificação.
 * - Se `meses_fruto[i]` for 1, o LED correspondente acende em **branco** (`RGB(255, 255, 255)`).
 * - Se `meses_fruto[i]` for 0, o LED correspondente é apagado.
 */
void fita_MONTH_mudanca_cor_F5(const Arvore *arvore) {
    for (int i = 0; i < NUM_LEDS_MONTH_F5; i++) {
        if (arvore->meses_fruto[i]) {
            delay(500);
            fita_MONTH_FRUIT.setPixelColor(i, fita_FRUIT.Color(255, 0, 128)); // rosa
            Serial.println(i);
            fita_MONTH_FRUIT.show();
        } else {
            fita_MONTH_FRUIT.setPixelColor(i, fita_FRUIT.Color(0, 0, 0)); // Apagar LED
        }
    }
}

/**
 * @brief Atualiza os LEDs para indicar a presença de frutos e os meses de frutificação.
 * 
 * @param status Indica se os LEDs devem ser acesos (1) ou apagados (0).
 * @param arvore Ponteiro para a estrutura `Arvore`, que contém informações sobre a presença de frutos e os meses de frutificação.
 * 
 * @details
 * - Se `status` for 1:
 *   - Se a árvore tiver frutos (`presenca_fruto == 1`), acende a fita `fita_FRUIT` na **cor verde** (`RGB(0, 255, 0)`).
 *   - Se não houver frutos, acende a fita `fita_FRUIT` na **cor vermelha** (`RGB(255, 0, 0)`).
 *   - A função `fita_MONTH_mudanca_cor_F5()` é chamada para acender os LEDs dos meses de frutificação.
 * - Se `status` for 0, todas as fitas são apagadas.
 */
void atualizarLeds_F5(int status, const Arvore* arvore) {
    if (status) {
        fita_FRUIT.clear();
        fita_MONTH_FRUIT.clear();

        if (arvore->presenca_fruto) {
            fita_FRUIT.setPixelColor(0, fita_FRUIT.Color(0, 255, 0)); // Verde (tem fruto)
            fita_FRUIT.show();
            fita_MONTH_mudanca_cor_F5(arvore);
        } else {
            fita_FRUIT.setPixelColor(0, fita_FRUIT.Color(255, 0, 0)); // Vermelho (sem fruto)
            fita_FRUIT.show();
        }
    } else {
        fita_FRUIT.clear();
        fita_FRUIT.show(); 
        fita_MONTH_FRUIT.clear();
        fita_MONTH_FRUIT.show();
    }
}

// ---------------------------- FACE 1 (Exibição de Informações display) ----------------------------

/**
 * @brief Desenha a imagem da copa da árvore no display, baseada no tipo de copa.
 * 
 * Esta função recebe um ponteiro para uma estrutura `Arvore` e, com base na 
 * string `copa`, seleciona e exibe a imagem correspondente no display.
 * 
 * @param arvore Ponteiro para a estrutura `Arvore` que contém as informações da árvore.
 * 
 * @note As imagens são armazenadas em arrays de bytes (hexadecimais) e desenhadas
 *       com a função `display.drawXBMP()`, que exibe bitmaps monocromáticos.
 * 
 * @warning Se `arvore` for `nullptr`, a função retorna imediatamente sem desenhar nada.
 */
void desenhaImagem(const Arvore* arvore) {
    if (!arvore) return;

    if (strcmp(arvore->copa, "Copa: Alongada") == 0) {
        display.drawXBMP(90, 10, 35, 60, alongada1);
        display.drawXBMP(0, 10, 30, 60, alongada2);
    } 
    else if (strcmp(arvore->copa, "Copa: Arredondada") == 0) {
        display.drawXBMP(70, 20, 50, 50, arredonda1);
        display.drawXBMP(0, 20, 50, 50, arredonda2);
    } 
    else if (strcmp(arvore->copa, "Copa: Expansiva/Guarda-chuva") == 0) {
        display.drawXBMP(0, 20, 56, 50, expansiva1);
        display.drawXBMP(70, 20, 50, 50, expansiva2);
    } 
    else if (strcmp(arvore->copa, "Copa: Irregular") == 0) {
        display.drawXBMP(70, 10, 39, 55, irregular1);
        display.drawXBMP(5, 25, 50, 39, irregular2);
    } 
    else {
        display.drawXBMP(80, 0, 35, 60, pinheiro);
    }
}




/**
 * @brief Exibe um texto no display, com rolagem caso seja maior que a largura da tela.
 * 
 * Esta função imprime o conteúdo fornecido no display. Se o texto for maior que a 
 * largura do display, ele será rolado horizontalmente. Se houver uma árvore associada,
 * sua imagem será desenhada no fundo da tela.
 * 
 * @param conteudo Texto a ser exibido no display.
 * @param cursorX Posição inicial do texto no eixo X.
 * @param cursorY Posição inicial do texto no eixo Y.
 * @param arvore Ponteiro para uma estrutura `Arvore`, usada para desenhar a imagem associada.
 * 
 * @note O texto rola da direita para a esquerda quando excede a largura do display.
 * 
 * @warning Se `arvore` for `nullptr`, apenas o texto será exibido.
 */
void exibeTextoRolagem(const char* conteudo, int cursorX, int cursorY, const Arvore* arvore) {
    int larguraTexto = display.getStrWidth(conteudo);
    int larguraDisplay = display.getWidth();

    if (larguraTexto <= larguraDisplay) {  // TEXTO SEM ROLAMENTO
        display.clearBuffer();
        if (arvore) desenhaImagem(arvore);  // COM IMAGEM
        display.setCursor(cursorX, cursorY);
        display.print(conteudo);
        display.sendBuffer();
    } else { // TEXTO COM ROLAMENTO
        for (int offset = 0; offset < larguraTexto - larguraDisplay; offset++) {
            display.clearBuffer();
            desenhaImagem(arvore); // COM IMAGEM
            display.setCursor(-offset, cursorY);
            display.print(conteudo);
            display.sendBuffer();

            if (offset == 0) delay(2000);  // Pequena pausa antes de iniciar a rolagem
            delay(100);  // Controle da velocidade de rolagem
        }
    }
}


/**
 * @brief Exibe duas informações adicionais no display sem limpar a tela.
 * 
 * Esta função imprime dois títulos seguidos de separadores e, logo abaixo de cada um, 
 * exibe seus respectivos conteúdos. Ela mantém a tela sem limpeza para que outras 
 * informações permaneçam visíveis.
 * 
 * @param titulo1 O primeiro título da informação (exemplo: "Bioma").
 * @param conteudo1 O primeiro conteúdo (exemplo: "Amazônia").
 * @param titulo2 O segundo título da informação (exemplo: "Origem").
 * @param conteudo2 O segundo conteúdo (exemplo: "Brasil").
 * @param cursorX Posição X onde o texto será impresso.
 * @param cursorY Posição Y onde a primeira informação será impressa.
 */
void exibeDuasInformacoes(const char* titulo1, const char* conteudo1, 
                          const char* titulo2, const char* conteudo2, 
                          int cursorX, int cursorY) {
    
    display.clearBuffer();
     display.setCursor(cursorX - 1, cursorY);
    display.print(titulo1);
    display.setCursor(cursorX + 46, cursorY);
    display.print(conteudo1);

    display.setCursor(cursorX ,cursorY + 20);
    display.print("---------------------------------------");

    // Exibir segunda informação logo abaixo da primeira
    display.setCursor(cursorX, cursorY + 40);
    display.print(titulo2);
    display.setCursor(cursorX + 42, cursorY + 40);
    display.print(conteudo2);

    display.sendBuffer();
}



/**
 * @brief Verifica se um botão foi pressionado.
 * 
 * Esta função detecta a transição do estado do botão de "não pressionado" para "pressionado", 
 * utilizando uma variável de controle para evitar múltiplas detecções devido ao bouncing (efeito de contato mecânico). 
 * Ao detectar a pressão, retorna `true` uma única vez até que o botão seja liberado.
 * 
 * @param botao Pino digital onde o botão está conectado.
 * @param pressionado Referência para uma variável booleana que armazena o estado atual do botão 
 *                    (true se já foi detectado pressionado e ainda não liberado, false caso contrário).
 * 
 * @return `true` se o botão foi pressionado, `false` caso contrário.
 */
bool botaoPressionado(int botao, bool &pressionado) {
    if (digitalRead(botao) == LOW && !pressionado) {
        delay(50); 
        pressionado = true;
        return true;
    }
    if (digitalRead(botao) == HIGH) {
        pressionado = false;
    }
    return false;
}

/**
 * @brief "Janela de interação": Exibe as informações de uma árvore identificada e aguarda interações do usuário.
 * 
 * Esta função limpa o display, exibe uma mensagem inicial de árvore identificada e, 
 * em seguida, entra em um loop de interação onde o usuário pode pressionar diferentes botões 
 * para visualizar informações específicas sobre a árvore ou ativar efeitos de LEDs em diferentes faces.
 * 
 * - Botão F1 (Nome): Exibe o nome da árvore com rolagem, se necessário.
 * - Botão F1 (Origem): Exibe a origem e o bioma da árvore.
 * - Botão F1 (Copa): Exibe informações sobre a copa da árvore com rolagem, se necessário.
 * - Botão F2, F4 e F5: Alternam o estado das fitas de LED relacionadas às interações dessas faces.
 * - Botão F1 (Saída): Sai do modo de interação, apaga todas as fitas de LEDs e retorna à mensagem inicial.
 * 
 * Flags internas são utilizadas para evitar múltiplas leituras consecutivas dos botões (debounce).
 * 
 * @param arvore Ponteiro para a estrutura `Arvore` contendo os dados que serão exibidos.
 */
void exibirInformacoesArvore(const Arvore* arvore) {

  display.clearBuffer();
  display.setFont(u8g2_font_ncenB08_tr);
  display.drawStr(45, 30, "Arvore");
  display.drawStr(30, 50, "identificada!");
  display.sendBuffer();
  delay(2000);

  bool botao1Pressionado_F1 = false;  // Flag para evitar múltiplas leituras
  bool botao2Pressionado_F1 = false;  // Flag para evitar múltiplas leituras
  bool botao3Pressionado_F1 = false;  // Flag para evitar múltiplas leituras

  bool botaoPressionado_F5 = false;  
  bool botaoPressionado_F4 = false;
  bool botaoPressionado_F2 = false;
  int atualiza_Leds_F5 = 0;  // Variável de controle para alternar o estado dos LEDs FACE 5
  int atualiza_Leds_F4 = 0;  // Variável de controle para alternar o estado dos LEDs FACE 4
  int atualiza_Leds_F2 = 0;  // Variável de controle para alternar o estado dos LEDs FACE 2

  while(1){

    if (botaoPressionado(BOTAO_F1_NOME, botao1Pressionado_F1)){ 
      
      Serial.println("BOTAO 1 PRESSIOANDO");
      exibeTextoRolagem(arvore->nome, 0, 40, NULL);

 
    }
    if (botaoPressionado(BOTAO_F1_ORIGEM, botao2Pressionado_F1)) {
      
      exibeDuasInformacoes("Origem: ", arvore->pais_origem, "Bioma: ", arvore->bioma, 0, 15);
    }

    if (botaoPressionado(BOTAO_F1_COPA, botao3Pressionado_F1)) {
    
      exibeTextoRolagem(arvore->copa, 0, 10, arvore);
    }

    if (botaoPressionado(BOTAO_F2_INTERACAO, botaoPressionado_F2)) {
      Serial.println("INTERECAO F2: " + String(BOTAO_F2_INTERACAO));
      atualiza_Leds_F2 = !atualiza_Leds_F2;  // Alterna entre ligado/desligado
      atualizarLeds_F2(atualiza_Leds_F2, arvore);  // Atualiza o estado da fita de LED
    }

    if (botaoPressionado(BOTAO_F5_INTERACAO, botaoPressionado_F5)) {
      Serial.println("Aaqui");
      atualiza_Leds_F5 = !atualiza_Leds_F5;  // Alterna entre ligado/desligado
      atualizarLeds_F5(atualiza_Leds_F5, arvore);  // Atualiza o estado da fita de LED
    }

    if (botaoPressionado(BOTAO_F4_INTERACAO, botaoPressionado_F4)) {
      atualiza_Leds_F4 = !atualiza_Leds_F4;  // Alterna entre ligado/desligado
      atualizarLeds_F4(atualiza_Leds_F4, arvore);  // Atualiza o estado da fita de LED
    }
  
    if (digitalRead(BOTAO_F1_SAIDA) == LOW) {
      Serial.println("Saindo da janela dos botoes");
      exibirMensagemInicial();
      // Mantém os LEDs apagados até identificar nova arvore
        fita_FRUIT.clear();
        fita_FRUIT.show(); 
        fita_MONTH_FRUIT.clear();
        fita_MONTH_FRUIT.show();

        fita_FLOR.clear();
        fita_FLOR.show(); 
        fita_MONTH_FLOR.clear();
        fita_MONTH_FLOR.show();

        fitaF2.clear();
        fitaF2.show();
      
      break;
    }
  }
}

/**
 * @brief Exibe uma mensagem no display informando que a árvore não foi encontrada.
 * 
 * Esta função limpa o display, define a fonte e exibe a mensagem "Árvore não encontrada!" 
 * centralizada na tela. Após exibir a mensagem, aguarda um tempo definido pela constante `TEMPO_EXIBICAO`.
 * 
 * É utilizada quando a identificação da árvore falha ou o dado não está disponível.
 */
void exibirMensagemArvoreNaoEncontrada(){
    display.clearBuffer();
    display.setFont(u8g2_font_ncenB08_tr);
    display.drawStr(35, 30, "Arvore");
    display.drawStr(40, 40, " nao");
    display.drawStr(30, 50, "encontrada!");
    display.sendBuffer();
    delay(TEMPO_EXIBICAO);
}

/**
 * @brief Loop principal do programa — "Janela de busca".
 * 
 * Esta função roda continuamente, aguardando a leitura de uma tag RFID.
 * Quando uma tag é detectada, o programa tenta identificar a árvore correspondente 
 * a partir do UID da tag.
 * 
 * - Se a árvore for encontrada, a função `exibirInformacoesArvore()` é chamada, 
 * entrando na "janela de Interação" oara exibição de informações detalhadas.
 * - Caso contrário, exibe a mensagem de árvore não encontrada através de `exibirMensagemArvoreNaoEncontrada()`.
 * 
 * Esta função representa o estado de espera e detecção do sistema.
 */
void loop() {
  byte uidBuffer[4];  // Buffer para armazenar o UID da tag RFID

  // Tenta ler o UID do cartão RFID
  if (!lerUID(uidBuffer)) {
    return;  // Se não conseguir ler, retorna imediatamente e aguarda nova tentativa
  }

  // Busca a árvore correspondente ao UID lido
  int index = procurarArvorePorUID(uidBuffer);

  if (index != -1) {
    Serial.println("Entrando na janela dos botões");
    exibirInformacoesArvore(&arvores[index]);  // Exibe as informações da árvore encontrada
  } else {
    exibirMensagemArvoreNaoEncontrada();  // Exibe mensagem de erro se a árvore não for encontrada
  }

}